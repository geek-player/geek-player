[{"title":"MyBatis","url":"/2023/05/21/MyBatis/","content":"Mybatis\n\n介绍\n对数据库中的表进行操作\n\n可以对数据库中的表进行操作的是JDBC\n\nJDBC是Java连接数据库的桥（方式）\n\n加载驱动（导入mysql-connector……）\n\nClass.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //反射\n\n\n建立连接\n\nString url = &quot;jdbc:mysql://localhost:3306/mybatis&quot;String username = &quot;root&quot; ;String password = &quot;root&quot; ;Connection connection = DriverManager.getConnection(url,username,password);\n\n\n创建PreparedStatement……\n\nString sql = &quot;SELECT * FROM user WHERE id = ?&quot;;PreparedStatement preparedStatement = connection.preparedStatem……(sql);preparedStatement.setInt(1,1);\n\n\nResultSet resultSet &#x3D; preparedStatement.executeQuery();\n\nif(resultSet.next())&#123;    System.sout,println(resultSet.getString(2));&#125;\n\n\n关闭（先开后关）\n\nresultSet.close();preparedStatement.close();connection.close();\n\n\nMyBatis项目\n\n\n\n缓存一级缓存：SqlSession（默认）\n二级缓存：Mapper\nSqlSessionFactory\n初始化MyBatis\n创建SqlSession\n全局唯一，存储在静态区\n\nSqlSession\n操作数据库核心，封装了JDBC加载驱动，建立链接，\n\n编写代码\n实体类：参考表结构与自己的需要\n\n接口类：dao层下的接口（抽象方法、默认方法和静态方法）\n\npublic int insert (User user);\npublic int update (User user);\npublic int delete (int id);\npublic User selectById(int id);\npublic List&lt;User&gt; select();\npublic User login(@Param(&#39;username&#39;) String username,@Param(&#39;password&#39;) String password)\n\n\n映射文件： \n\n映射文件路径一定与接口类路径一致\n\n映射文件名与类名一致\n\n映射文件中的namespace，写成接口类的全路径包名.接口类名、\n\n映射文件中的 id 就是接口类中的方法名（id不可能重复）\n\n映射文件中的parameterType，写的内容与接口类中的形参一致\n若形参的类型是基础类型或String，且只有一个，则默认可不写，可以自动映射\n若形参的类型是非基础类型或String，且只有一个，则需要在映射文件中写类名\n若形参的类型是两个及以上基础类型或String，映射文件建议使用@Param\n\n映射文件中的 resultType，写的是返回值类型（insert、delete、update无此属性）\n若是一个基础类型或String，则可以不写\n若是一个类或者集合，则直接写类名\n要求：列名与属性名、列名对应的类型与属性名对应的类型一致，若不满足如上要求使用resultMap\n\n\n\n\n\n堆：new方法\n栈：方法被调用\n方法区：类加载，所有方法加载到这里（包括静态方法）\n静态区：静态变量和常量\n\n","tags":["JavaEE"]},{"title":"SSM","url":"/2023/06/11/SSM/","content":"SSM项目开发\n设计表\n创建Web项目\n编写代码\n\n\nsrc\n\njava\n参考表操作\nentity&#x2F;bean&#x2F;model&#x2F;pojo\n\n\n对db操作，类，现有mybatis创建接口\nmapper&#x2F;dao\n\n\n接受controller的要求，根据dao的结果返回\nservice\n\n\n接受请求，调用service，返回给用户\ncontroller\n\n\n\n\nresource\n接口映射文件\nmapper&#x2F;dao\n\n\n加载所有配置文件\napplication.xml\n\n\n加载db.properties，配置连接池，sqlSessionFactory，tx，aop\nspring.xml\n\n\n视图解析器，释放静态资源，处理json数据，上传\nspringmvc.xml\n\n\n起别名，配置缓存，配置日志，加载映射文件\nmybatis.xml\n\n\n连接数据库的基础属性\ndb.properties\n\n\n日志\nlog…\n\n\n\n\nwebapp\nWEB-INF\nFilter过滤乱码，DispatcherServlet[加载applicationContext.xml]\nweb.xml\n\n\n编译后的字节码文件\nclasses\n\n\nindex.jsp\n\n\n\n\n\n\npom.xml\n\nspring-webmvc\nspring-tx\nspring-aspects\nspring-jdbc\nmybatis\nmybatis-spring\ndruid\njunit\nmysql-connector-java\n\n\n\n","tags":["JavaEE"]},{"title":"Spring","url":"/2023/05/21/Spring/","content":"Spring\n\n介绍版本\nSNAPSHOT：快照版（测试版）\nRELEASE：稳定版\nGA：正式版\nM：里程碑版\nRC：终测版\n\n特点\nIOC：控制反转换，以前的类需要自己new，现在可以直接从spring容器中取出（Bean注入）\n\nIOC容器里装的是配置的Bean或者类头上注解需要让spring帮我们创建的类（类的对象）\n\n依赖注入：Spring容器里装了所有需要的类对象，依赖spring创建类\n控制反转：Spring IOC 容器具有最高的权力，以前最高权力是自己\n\n\n以前自己建自己用，现在直接拿来用\nIOC  创建bean  →  类  →  对象\n\n\n\n\nAOP：面向切面编程，应用关注你该实现的，不负责其他关注点（事务、日志）\n\nMVC：整合Spring作用，企业级的解决方案\n\n轻量级框架\n\n轻量：1MB左右\n非侵入式：\n通过配置完成注入，易于在框架外使用，\nController类就是一个普通的类，但是可以作为控制层的入口\n\n\n框架：将简单的组件配置到一起（利用XML文件）\n\n\n侵入式：要求类必须继承或者实现框架中的内容，才可以实现效果，例如：struts 2\n\n\n\n给我们的开发带来了什么好处?\n\n更干净，更可管理\n\n\nentity&#x2F;model&#x2F;pojo –&gt; 表\ndao&#x2F;mapper –&gt; DB操作\nservice –&gt; 业务逻辑层，AOP切入\ncontroller –&gt; Servlet\nutile –&gt; 工具类\n\n海纳百川\nspring-jdbc：Spring可以与数据库建立关系，JPA\n\nSpring模块\nspring-context：IOC容器\nspring_core：IOC与DI的实现\nspring-beans：Bean工程\nspring-aop：AOP\nspring-jdbc：对JDBC的封装\nspring-tx：JDBC事务控制处理\nspring-web：对web基础支持\nspring-webmvc：实现SpringMVC\n\n\nIOC：控制反转，是一种思想\nDI：依赖注入，是思想的实现方式\n带来最大的好处就是解耦，以前需要自己new，每个类、模块之间都有密切的关系，一旦某个模块发生问题，整个系统瘫痪，耦合度太高（关系密切）\n想解耦，就要降低他们之间的关系，全部交给容器来控制（IOC）\n\n\n\n\n\nIOCspring-config.xml基础数据类型注入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 表示Spring帮我创建类，id要唯一 --&gt;    &lt;!-- &lt;bean id=&quot;user&quot; class=&quot;com.wxh.entity.User&quot;&gt; --&gt;    &lt;!-- 属性注入 通过set方法 --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.wxh.entity.User&quot; p:password=&quot;Administrator&quot;&gt;        &lt;!-- 中的属性名要根据set方法的方法名，而非实体类中的属性名 --&gt;        &lt;property name=&quot;username&quot; value=&quot;user&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 利用构造器插入属性值 通过构造方法 --&gt;    &lt;bean id=&quot;user1&quot; class=&quot;com.wxh.entity.User&quot;&gt;        &lt;!-- 中的属性名要根据set方法的方法名，而非实体类中的属性名 --&gt;        &lt;constructor-arg name=&quot;username&quot; value=&quot;user1&quot;/&gt;        &lt;constructor-arg name=&quot;password&quot; value=&quot;Administrator&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 若省略name，则需要根据形参列表的顺序写 --&gt;    &lt;bean id=&quot;user2&quot; class=&quot;com.wxh.entity.User&quot;&gt;        &lt;!-- 中的属性名要根据set方法的方法名，而非实体类中的属性名 --&gt;        &lt;constructor-arg value=&quot;user2&quot;/&gt;        &lt;constructor-arg value=&quot;Administrator&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 若省略name，且参数顺序与形参列表顺序不一致，则通过index指定是第几个参数的值 --&gt;    &lt;bean id=&quot;user3&quot; class=&quot;com.wxh.entity.User&quot;&gt;        &lt;!-- 中的属性名要根据set方法的方法名，而非实体类中的属性名 --&gt;        &lt;constructor-arg name=&quot;password&quot; value=&quot;Administrator&quot;/&gt;        &lt;constructor-arg name=&quot;username&quot; value=&quot;user3&quot; index=&quot;0&quot;/&gt;    &lt;/bean&gt;    &lt;!-- 利用c标签简化constructor-arg --&gt;    &lt;bean id=&quot;user4&quot; class=&quot;com.wxh.entity.User&quot; c:username=&quot;user4&quot; c:password=&quot;Administrator&quot;/&gt;&lt;/beans&gt;\n\n测试代码：\n@Testpublic void test() &#123;    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring-config.xml&quot;);    // System.out.println(applicationContext.getBean(User.class));    System.out.println(applicationContext.getBean(&quot;user&quot;));    System.out.println(applicationContext.getBean(&quot;user1&quot;));    System.out.println(applicationContext.getBean(&quot;user2&quot;));    System.out.println(applicationContext.getBean(&quot;user3&quot;));    System.out.println(applicationContext.getBean(&quot;user4&quot;));&#125;\n\n引用数据类型注入&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;test&quot; class=&quot;com.wxh.entity.Test&quot;&gt;        &lt;property name=&quot;list&quot;&gt;            &lt;list&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=&quot;set&quot;&gt;            &lt;set&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;value&gt;3&lt;/value&gt;            &lt;/set&gt;        &lt;/property&gt;        &lt;property name=&quot;map&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;张三&quot; value=&quot;zhangsan&quot;/&gt;                &lt;entry key=&quot;李四&quot; value=&quot;lsii&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=&quot;userList&quot;&gt;            &lt;list&gt;                &lt;bean id=&quot;user1&quot; class=&quot;com.wxh.entity.User&quot; p:username=&quot;普通用户&quot; p:password=&quot;nimda&quot;/&gt;                &lt;ref bean=&quot;user2&quot;/&gt;            &lt;/list&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;user2&quot; class=&quot;com.wxh.entity.User&quot; p:username=&quot;管理员&quot; p:password=&quot;NIMDA&quot;/&gt;&lt;/beans&gt;\n\n测试代码：\n@Testpublic void test() &#123;    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;classpath:spring-test.xml&quot;);    System.out.println(applicationContext.getBean(&quot;test&quot;));&#125;\n\n当ApplicationContext实例化后，会将配置文件中所有的Bean注入到容器中（此时已经拥有所有Bean的对象）\n想让Spring帮忙创建类，类中必须要包含无参构造方法\n当加载配置文件时，配置中的所有Bean就会进入容器，此刻容器中就有了Bean对应类的对象名\n是否立即加载bean&lt;!-- 不立即加载， 只有使用或者子类被构建时才进行加载 --&gt;&lt;bean id=&quot;user&quot; class=&quot;com.wxh.entity.User&quot; abstract=&quot;true&quot;/&gt;&lt;!-- 继承user bean --&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.wxh.entity.User1&quot; parent=“user&quot;/&gt;\n\nSpring默认单例&lt;!-- 只创建一次，一直存在，static，默认单例模式，由IOC容器创建，由IOC管理 --&gt;&lt;bean id=&quot;user&quot; class=&quot;com.wxh.entity.User&quot; abstract=&quot;true&quot;/&gt;&lt;!-- 多实例 --&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.wxh.entity.User1&quot; parent=“user&quot; scope=&quot;prototype&quot;/&gt;\n\n注解// 声明在类的头部@Repository 仓库（Dao层），加上该注解可以让Spring控制@Controller 控制器@Service 业务层@Component 普通组件// 声明在属性上、set方法上（类中的那个属性想注入，就写在改属性头部即可）@Autowired \n\nAOPAOP使用场景：日志、事务、权限认证、安全检查\nAOP配置：\n通知\n环绕通知：在目标方法执行前后实施管理，通常用于日志、事务处理\n前置通知：在目标方法执行前，通常用于权限认证\n后置返回通知：在目标方法成功执行后，通常用于关闭流、删除临时文件等\n后置最终通知：在目标方法成功执行后，无论是否有异常，一定返回（finally），通常用于释放资源\n异常通知：方法抛出异常，通常用于异常处理\n引入通知：在目标类中新增一些属性和方法，通常用于修改目标类\n\n\n\nSpring—Mybatis","tags":["JavaEE"]},{"title":"SPringMVC","url":"/2023/06/11/SpringMVC/","content":"MVC：一种架构模式\nM：model\t\t数据和业务（service、mapper、entity）\nV：view\t\t视图\nC：controller\t中介、解耦、提高代码维护性\n\nServlet\n接受数据\n返回数据\n跳转\n转发\n重定向\n\n创建Servletimport javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class TestServlet extends HttpServlet &#123;  public void doGet(ServletRequest request, ServletResponse response) &#123;  &#125;  public void doPost(ServletRequest request, ServletResponse response) &#123;  &#125;&#125;\n配置Servlet&lt;web-app&gt;  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;TestServelct&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.ambow.servlet.TestServelct&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;变量名&lt;/param-name&gt;      &lt;param-value&gt;写对应的值&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!-- 项目启动时加载当前类 --&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;TestServelct&lt;/servlet-name&gt;    &lt;url-pattern&gt;/TestServlet&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;\nSpringMVC：\n基于SpringIOC容器运行 –&gt; 所有的controller交给Spring创建\n轻量级web mv框架，围绕DispatcherServlect，调用Servlet设计 –&gt; Servlet可做的，SpringMVC都可以做，而且更加强大\n\nSpringMVC开发步骤\n导入spring-webmvc\nweb.xml配置文件\n\nweb.xml&lt;web-app&gt;    &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:SpringMVC-config.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;\n3.SpringMVC-config.xml配置文件  \nSpringMVC-config.xml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.wxh.controller&quot;/&gt;&lt;/beans&gt;\n\nController类\n接收数据：\n\n基本类型：变量名与传递的key一致可以自动类型转换\n自定义类：类中属性名与传递的key一致，就可以自动类型转换\n任意名称：@RequestParam(&quot;key&quot;) Object value\n\n\n跳转：\n\n传值方式\nModelAndView\nRequest\nSession\nModel\n\n\n跳转方式\nModelAndView\nrequest.getRequestDispatcher…\nresponse.sendRedirect…  默认返回值是String，则返回值位置写的字符串就是转发到对应的jsp名字若想转发到controller，需要返回值位置写”forward:index.jsp”重定向到jsp:”redirect:xx.jsp”controller:”redirect:controller请求地址”\n\n\n\n\nmapper.xml：\n\nnamespace: mapper类的全路径\nid：抽象方法名\nparameterType：形参\nresultType&#x2F;resultMap：数据返回类型\n\n\n\n\n\n","tags":["JavaEE"]},{"title":"Hello World","url":"/2023/01/05/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Ambow","url":"/2023/07/24/Ambow/","content":"Ambow\n\nDay-01Java特性面向对象（万物皆对象）：\n封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。\n\n继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。\n\n多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。\n\n\nJDBCJDBC工具类package com.ambow.utils;import com.mysql.cj.jdbc.Driver;import java.sql.*;/** * @Author Admin * @create 2023/7/24 11:11 */public class JDBCUtils &#123;    /**     * 获取与MySQL数据努的连接     * @return 数据库连接     */    public static Connection getConnection()&#123;        Connection connection = null ;        Statement statement = null;        try &#123;            String url = &quot;jdbc:/mysql///demo&quot;;            String username = &quot;root&quot;;            String password = &quot;root&quot;;            String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;            try &#123;                Class.forName(driver);            &#125; catch (ClassNotFoundException e) &#123;                throw new RuntimeException(e);            &#125;            return DriverManager.getConnection(url,username,password);        &#125; catch (SQLException sqlException) &#123;            throw new RuntimeException(sqlException);        &#125;    &#125;    /**     * 关闭数据库连接     */    public static void close(Statement statement, Connection connection)&#123;        try &#123;            statement.close();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;        try &#123;            connection.close();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;    /**     * 关闭数据库连接     */    public static void close(Statement statement, Connection connection, ResultSet resultSet)&#123;        try &#123;            statement.close();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;        try &#123;            connection.close();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;        try &#123;            resultSet.close();        &#125; catch (SQLException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;\n\n\n\n作业用递归的方式获取该路径下的所有目录\npublic class Main &#123;    public static void main(String[] args) &#123;        directory(&quot;D:/Java/jdk1.8&quot;);    &#125;    public static void directory(String path) &#123;        File file = new File(path);        if ( ! file.isDirectory() ) &#123;            return;        &#125;        for (String s : Objects.requireNonNull(file.list())) &#123;            System.out.println(path + &quot;/&quot; + s);        &#125;        for ( String dir : Objects.requireNonNull(file.list()) )&#123;            directory(path + &quot;/&quot; + dir);        &#125;    &#125;&#125;\n\nDay-02Java基础语法一、变量\nbyte: 占用 1 个字节，取值范围-128 ~ 127\nshort: 占用 2 个字节，取值范围-2^15^ ~ 2^15^-1\nint：占用 4 个字节，取值范围-2^31^ ~ 2^31^-1\nlong：占用 8 个字节\nfloat：占用 4 个字节\ndouble：占用 8 个字节\nchar: 占用 2 个字节\nboolean：占用大小根据实现虚拟机不同有所差异\n\n二、运算1.算术运算符\n\n\n操作符\n描述\n例子（A&#x3D;10,B&#x3D;20）\n\n\n\n+\n加法 - 相加运算符两侧的值\nA + B &#x3D;&#x3D; 30\n\n\n-\n减法 - 左操作数减去右操作数\nA – B&#x3D;&#x3D; -10\n\n\n*\n乘法 - 相乘操作符两侧的值\nA * B &#x3D;&#x3D; 200\n\n\n&#x2F;\n除法 - 左操作数除以右操作数\nB &#x2F; A &#x3D;&#x3D; 2\n\n\n％\n取余 - 左操作数除以右操作数的余数\nB % A &#x3D;&#x3D; 0\n\n\n++\n自增: 操作数的值增加1\nB ++（先使用后自增） 或 ++ B （先自增后使用）\n\n\n- -\n自减: 操作数的值减少1\nB - -（先使用后自减）或 - - B （先自减后使用）\n\n\n2.关系运算符\n\n\n运算符\n描述\n例子（A&#x3D;10,B&#x3D;20）\n\n\n\n&#x3D;&#x3D;\n检查如果两个操作数的值是否相等，如果相等则条件为真。\n(A &#x3D;&#x3D; B) &#x3D;&#x3D; false\n\n\n!&#x3D;\n检查如果两个操作数的值是否相等，如果值不相等则条件为真。\n(A !&#x3D; B) &#x3D;&#x3D; true\n\n\n&gt;\n检查左操作数的值是否大于右操作数的值，如果是那么条件为真。\n(A &gt; B) &#x3D;&#x3D; false\n\n\n&lt;\n检查左操作数的值是否小于右操作数的值，如果是那么条件为真。\n(A &lt; B) &#x3D;&#x3D; true\n\n\n&gt;&#x3D;\n检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。\n(A &gt;&#x3D; B) &#x3D;&#x3D; false\n\n\n&lt;&#x3D;\n检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。\n(A &lt;&#x3D; B) &#x3D;&#x3D; true\n\n\n3.逻辑运算符\n\n\n操作符\n描述\n例子（A&#x3D;true,b&#x3D;false)\n\n\n\n&amp;&amp;\n称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。\n(A &amp;&amp; B) &#x3D;&#x3D; flase\n\n\n||\n称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。\n( A || B) &#x3D;&#x3D; true\n\n\n!\n称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。\n! ( A &amp;&amp; B) &#x3D;&#x3D; true\n\n\n4.赋值运算符\n\n\n操作符\n描述\n例子\n\n\n\n&#x3D;\n简单的赋值运算符，将右操作数的值赋给左侧操作数\nC &#x3D; A + B将把A + B得到的值赋给C\n\n\n+&#x3D;\n加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数\nC +&#x3D; A等价于C &#x3D; C + A\n\n\n-&#x3D;\n减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数\nC -&#x3D; A等价于C &#x3D; C - A\n\n\n*&#x3D;\n乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数\nC *&#x3D; A等价于C &#x3D; C * A\n\n\n&#x2F;&#x3D;\n除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数\nC &#x2F;&#x3D; A，C 与 A 同类型时等价于 C &#x3D; C &#x2F; A\n\n\n（％）&#x3D;\n取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数\nC ％&#x3D; A等价于C &#x3D; C ％ A\n\n\n&lt;&lt;&#x3D;\n左移位赋值运算符\nC &lt;&lt;&#x3D; 2等价于C &#x3D; C &lt;&lt; 2\n\n\n&gt;&gt;&#x3D;\n右移位赋值运算符\nC &gt;&gt;&#x3D; 2等价于C &#x3D; C &gt;&gt; 2\n\n\n＆&#x3D;\n按位与赋值运算符\nC ＆&#x3D; 2等价于C &#x3D; C＆2\n\n\n^&#x3D;\n按位异或赋值操作符\nC ^&#x3D; 2等价于C &#x3D; C ^ 2\n\n\n|&#x3D;\n按位或赋值操作符\nC |&#x3D; 2等价于C &#x3D; C | 2\n\n\n三、循环1.while循环while( 布尔表达式 ) &#123;    //循环内容&#125;\n\n2.for循环for(初始化; 布尔表达式; 更新) &#123;    //循环内容&#125;\n\n四、数组int[] array = new int[100];int numbers[] = new int[100];String[] week = new String[]&#123;&quot;周一&quot;,&quot;周二&quot;,&quot;周三&quot;,&quot;周四&quot;,&quot;周五&quot;,&quot;周六&quot;,&quot;周日&quot;&#125;;\n\n五、数组冒泡排序int[] array = new int[]&#123;36, 26, 27, 2, 4, 19, 50, 48&#125;;for ( int i = 0 ; i &lt; array.length - 1 ; i ++ ) &#123;    for ( int j = 0 ; j &lt; array.length - i - 1 ; j ++ ) &#123;        if ( array [ j ] &gt; array [ j + 1 ] )&#123;            int t = array [ j + 1 ] ;            array [ j + 1 ] = array [ j ] ;            array [ j ] = t ;        &#125;    &#125;&#125;System.out.println(Arrays.toString(array));// 输出结果// [2, 4, 19, 26, 27, 36, 48, 50]\n\n\n\n斐波那契数列BigInteger a = new BigInteger(&quot;1&quot;);BigInteger b = new BigInteger(&quot;1&quot;);System.out.print(&quot;[&quot;);System.out.print(a);System.out.print(&quot;,&quot; + b);for (int i = 0; i &lt; 18; i++) &#123;    if (i % 2 == 0) &#123;        a = a.add(b);        System.out.print(&quot;,&quot; + a);    &#125; else &#123;        b = b.add(a);        System.out.print(&quot;,&quot; + b);    &#125;&#125;System.out.print(&quot;]&quot;);// 输出结果// [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]\n\n六、面向对象","tags":["Ambow"]},{"title":"Java集合面试题","url":"/2023/07/25/Java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"\n一、集合容器概述1. 什么是集合\n集合就是一个放数据的容器，准确的说是放数据对象引用的容器\n集合类存放的都是对象的引用，而不是对象的本身\n集合类型主要有3种：set(集）、list(列表）和map(映射)。\n\n2. 集合的特点\n集合的特点主要有如下两点：\n集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理。\n和数组对比对象的大小不确定。因为集合是可变长度的。数组需要提前定义大小\n\n\n\n3. 集合和数组的区别\n数组是固定长度的；集合可变长度的。\n数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。\n数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。\n\n4. 使用集合框架的好处\n容量自增长；\n提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；\n可以方便地扩展或改写集合，提高代码复用性和可操作性。\n通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。\n\n5. 常用的集合类有哪些？\nMap接口和Collection接口是所有集合框架的父接口：\nCollection接口的子接口包括：Set接口和List接口\nMap接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等\nSet接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等\nList接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等\n\n\n\n6. List，Set，Map三者的区别？\n\nJava 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。\n\nCollection集合主要有List和Set两大接口\n\nList：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。\nSet：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及TreeSet。\n\n\nMap是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重\n复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应\n的值对象。\n\nMap 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap\n\n\n\n7. 集合框架底层数据结构\nCollection\nList* Arraylist： Object数组* Vector： Object数组* LinkedList： 双向循环链表\nSet* HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素* LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。* TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)\n\n\nMap\nHashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间\nLinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。\nHashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的\nTreeMap： 红黑树（自平衡的排序二叉树）\n\n\n\n8. 哪些集合类是线程安全的？\nVector：就比Arraylist多了个 synchronized （线程安全），因为效率较低，现在已经不太建议使用。\nhashTable：就比hashMap多了个synchronized (线程安全)，不建议使用。\nConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）\n\n9. Java集合的快速失败机制 “fail-fast”？\n是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast 机制。\n例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。\n原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。\n解决办法：\n\n\n在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。\n使用CopyOnWriteArrayList来替换ArrayList\n\n10. 怎么确保一个集合不能被修改？\n可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。\n示例代码如下：\n\nList&lt;String&gt; list = new ArrayList&lt;&gt;();list. add(&quot;x&quot;);Collection&lt;String&gt; clist = Collections. unmodifiableCollection(list);clist. add(&quot;y&quot;); // 运行时此行报错System. out. println(list. size());\n\n\n二、Collection接口List接口11. 迭代器 Iterator 是什么？\nIterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。\n因为所有Collection接继承了Iterator迭代器\n\npublic interface Collection&lt;E&gt; extends Iterable&lt;E&gt;&#123;\t// Query Operations&#125;\n\n12. Iterator 怎么使用？有什么特点？\nIterator 使用代码如下：\n\nList&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; it = list. iterator();while(it. hasNext())&#123;\tString obj = it. next();\tSystem. out. println(obj);&#125;\n\n\nIterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。\n\n13. 如何边遍历边移除 Collection 中的元素？边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：\nIterator&lt;Integer&gt; it = list.iterator();while(it.hasNext())&#123;\t*// do something*\tit.remove();&#125;\n\n一种最常见的错误代码如下：\nfor(Integer i : list)&#123;\tlist.remove(i)&#125;\n\n\n运行以上错误代码会报 ConcurrentModificationException 异常。这是因为当使用foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。\n\n14. Iterator 和 ListIterator 有什么区别？\nIterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。\nIterator 只能单向遍历，而 ListIterator 可以双向遍历（向前&#x2F;后遍历）。\nListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。\n\n15. 遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？\n遍历方式有以下几种：\n\nfor 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。\n迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。\nforeach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。\n\n\n最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支\n持 Random Access。\n\n如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。\n如果没有实现该接口，表示不支持 Random Access，如LinkedList。\n推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或foreach 遍历。\n\n\n\n16. 说一下 ArrayList 的优缺点\nArrayList的优点如下：\nArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。\nArrayList 在顺序添加一个元素的时候非常方便。\n\n\nArrayList 的缺点如下：\n删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。\n插入元素的时候，也需要做一次元素复制操作，缺点同上。\n\n\nArrayList 比较适合顺序添加、随机访问的场景。\n\n17. 如何实现数组和 List 之间的转换？\n数组转 List：使用 Arrays. asList(array) 进行转换。\nList 转数组：使用 List 自带的 toArray() 方法。\n代码示例：\n\n// list to arrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;123&quot;);list.add(&quot;456&quot;);list.toArray();// array to listString[] array = new String[]&#123;&quot;123&quot;,&quot;456&quot;&#125;;Arrays.asList(array);\n\n18. ArrayList 和 LinkedList 的区别是什么？\n数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。\n随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。\n增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为ArrayList 增删操作要影响数组内的其他数据的下标。\n内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。\n线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；\n综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。\nLinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。\n\n19. ArrayList 和 Vector 的区别是什么？\n这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合\n线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。\n性能：ArrayList 在性能方面要优于 Vector。\n扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。\n\n\nVector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。\nArraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。\n\n20. 插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述\nArrayList、Vector、LinkedList 的存储性能和特性？ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。\nVector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。\nLinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。\n\n21. 多线程场景下如何使用 ArrayList？ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：\nList&lt;String&gt; synchronizedList = Collections.synchronizedList(list);synchronizedList.add(&quot;aaa&quot;);synchronizedList.add(&quot;bbb&quot;);for (int i = 0; i &lt; synchronizedList.size(); i++) &#123;    System.out.println(synchronizedList.get(i));&#125;\n\n22. 为什么 ArrayList 的 elementData 加上 transient 修饰？\nArrayList 中的数组定义如下：private transient Object[] elementData;\n再看一下 ArrayList 的定义：\n\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; \timplements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable\n\n\n可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：\n\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123;\t// Write out element count, and any hidden stuff\tint expectedModCount = modCount;\ts.defaultWriteObject();\t// Write out array length\ts.writeInt(elementData.length);\t// Write out all elements in the proper order.\tfor (int i=0; i&lt;size; i++)\t\ts.writeObject(elementData[i]);\tif (modCount != expectedModCount) &#123;\t\tthrow new ConcurrentModificationException();&#125;\n\n\n每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。\n\n23. List 和 Set 的区别\nList , Set 都是继承自Collection 接口\nList 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。\nSet 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及TreeSet。\n另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。\nSet和List对比\nSet：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。\nList：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变\n\n\n\nSet接口24. 说一下 HashSet 的实现原理？\nHashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层HashMap 的相关方法来完成，HashSet 不允许重复的值。\n\n25. HashSet如何检查重复？HashSet是如何保证数据不可重复的？\n向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。\nHashSet 中的add ()方法会使用HashMap 的put()方法。\nHashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（HashMap 比较key是否相等是先比较hashcode 再比较equals ）。\n以下是HashSet 部分源码：\n\nprivate static final Object PRESENT = new Object();private transient HashMap&lt;E,Object&gt; map;public HashSet() &#123;    map = new HashMap&lt;&gt;();&#125;public boolean add(E e) &#123;    // 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值    return map.put(e, PRESENT)==null;&#125;\n\nhashCode（）与equals（）的相关规定：\n\n如果两个对象相等，则hashcode一定也是相同的* hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值\n两个对象相等,对两个equals方法返回true\n两个对象有相同的hashcode值，它们也不一定是相等的\n综上，equals方法被覆盖过，则hashCode方法也必须被覆盖\nhashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。\n\n&#x3D;&#x3D;与equals的区别\n\n&#x3D;&#x3D;是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同\n&#x3D;&#x3D;是指对内存地址进行比较 equals()是对字符串的内容进行比较\n\n26. HashSet与HashMap的区别\n\n\nHashMap\nHashSet\n\n\n\n实现了Map接口\n实现Set接口\n\n\n存储键值对\n仅存储对象\n\n\n调用put（）向map中添加元素\n调用add（）方法向Set中添加元素\n\n\nHashMap使用键（Key）计算Hashcode\nHashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false\n\n\nHashMap相对于HashSet较快，因为它是使用唯一的键获取对象\nHashSet较HashMap来说比较慢\n\n\n\n三、Map接口27. 什么是Hash算法\n哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。\n\n28. 什么是链表\n链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能。\n链表大致分为单链表和双向链表\n单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针\n双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针\n\n\n链表的优点\n插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）\n内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）\n大小没有固定，拓展很灵活。\n\n\n链表的缺点\n不能随机查找，必须从第一个开始遍历，查找效率低\n\n\n\n29. 说一下HashMap的实现原理？\nHashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。\nHashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\nHashMap 基于 Hash 算法实现的\n当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标\n存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中\n获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。\n理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。\n\n\n需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)\n\n30. HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现\n在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。\n\nHashMap JDK1.8之前\n\nJDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。HashMap JDK1.8之后\n相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。\n\nJDK1.7 VS JDK1.8 比较\n\nJDK1.8主要解决或优化了一下问题：\nresize 扩容优化\n引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考\n解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。\n\n\n\n\n\n\n不同\nJDK 1.7\nJDK 1.8\n\n\n\n存储结构\n数组 + 链表\n数组 + 链表 + 红黑树\n\n\n初始化方式\n单独函数： inflateTable()\n直接集成到了扩容函数 resize() 中\n\n\nhash值计算方式\n扰动处理 &#x3D; 9次扰动 &#x3D; 4次位运算 + 5次异或运算\n扰动处理 &#x3D; 2次扰动 &#x3D; 1次位运算 + 1次异或运算\n\n\n存放数据的规则\n无冲突时，存放数组；冲突时，存放链表\n无冲突时，存放数组；冲突 &amp; 链表长度 &lt;8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树\n\n\n插入数据方式\n头插法（先讲原位置的数据移到后1位，再插入数据到该位置）\n尾插法（直接插入到链表尾部&#x2F;红黑树）\n\n\n扩容后存储位置的计算方式\n全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）\n按照扩容后的规律计算（即扩容后的位置&#x3D;原位置 or 原位置 + 旧容量）\n\n\n31. 什么是红黑树说道红黑树先讲什么是二叉树\n\n二叉树简单来说就是 每一个节上可以关联俩个子节点\n\n大概就是这样子：\t\t     a          /     \\\t\t/         \\\t   b           c\t /   \\       /   \\\td     e     f     g   / \\   / \\   / \\   / \\  h   i j   k l   m n   o\n\n红黑树\n\n红黑树是一种特殊的二叉查找树。红黑树的每个结点上都有存储位表示结点的颜色，可以是红(Red)或黑(Black)。\n红黑树的每个结点是黑色或者红色。当是不管怎么样他的根结点是黑色。每个叶子结点（叶子结点代表终结、结尾的节点）也是黑色 [注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！]。\n如果一个结点是红色的，则它的子结点必须是黑色的。\n每个结点到叶子结点NIL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]\n红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的结点之后，红黑树的结构就发生了变化，可能不满足上面三条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转和变色，可以使这颗树重新成为红黑树。简单点说，旋转和变色的目的是让树保持红黑树的特性。\n\n32. HashMap的put方法的具体流程？\n当我们put的时候，首先计算 key 的 hash 值，这里调用了 hash 方法， hash 方法实际是让key.hashCode() 与 key.hashCode()&gt;&gt;&gt;16 进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标 index &#x3D; (table.length - 1) &amp; hash ，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。\nputVal方法执行流程图\n\npublic V put( K key, V value )&#123;\treturn(putVal( hash( key ), key, value, false, true ) );&#125;static final int hash( Object key )&#123;\tint h;\treturn( (key == null) ? 0 : (h = key.hashCode() ) ^ (h &gt;&gt;&gt; 16) );&#125;/* 实现Map.put和相关方法 */final V putVal( int hash, K key, V value, boolean onlyIfAbsent,\t\tboolean evict )&#123;\tNode&lt;K, V&gt;[] tab; Node&lt;K, V&gt; p; int n, i;\t/*\t * 步骤①：tab为空则创建\t * table未初始化或者长度为0，进行扩容\t */\tif ( (tab = table) == null || (n = tab.length) == 0 )\t\tn = (tab = resize() ).length;\t/*\t * 步骤②：计算index，并对null做处理\t * (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)\t */\tif ( (p = tab[i = (n - 1) &amp; hash]) == null )\t\ttab[i] = newNode( hash, key, value, null );\t/* 桶中已经存在元素 */\telse &#123;\t\tNode&lt;K, V&gt; e; K k;\t\t/*\t\t * 步骤③：节点key存在，直接覆盖value\t\t * 比较桶中第一个元素(数组中的结点)的hash值相等，key相等\t\t */\t\tif ( p.hash == hash &amp;&amp;\t\t     ( (k = p.key) == key || (key != null &amp;&amp; key.equals( k ) ) ) )\t\t\t/* 将第一个元素赋值给e，用e来记录 */\t\t\te = p;\t\t/*\t\t * 步骤④：判断该链为红黑树\t\t * hash值不相等，即key不相等；为红黑树结点\t\t * 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null\t\t */\t\telse if ( p instanceof TreeNode )\t\t\t/* 放入树中 */\t\t\te = ( (TreeNode&lt;K, V&gt;)p).putTreeVal( this, tab, hash, key, value );\t\t/*\t\t * 步骤⑤：该链为链表\t\t * 为链表结点\t\t */\t\telse &#123;\t\t\t/* 在链表最末插入结点 */\t\t\tfor ( int binCount = 0;; ++binCount )\t\t\t&#123;\t\t\t\t/*\t\t\t\t * 到达链表的尾部\t\t\t\t * 判断该链表尾部指针是不是空的\t\t\t\t */\t\t\t\tif ( (e = p.next) == null )\t\t\t\t&#123;\t\t\t\t\t/* 在尾部插入新结点 */\t\t\t\t\tp.next = newNode( hash, key, value, null );\t\t\t\t\t/* 判断链表的长度是否达到转化红黑树的临界值，临界值为8 */\t\t\t\t\ti f( binCount &gt;= TREEIFY_THRESHOLD - 1 ) /* -1 for 1st */\t\t\t\t\t/* 链表结构转树形结构 */\t\t\t\t\ttreeifyBin( tab, hash );\t\t\t\t\t/* 跳出循环 */\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\t/* 判断链表中结点的key值与插入的元素的key值是否相等 */\t\t\t\tif ( e.hash == hash &amp;&amp;\t\t\t\t     ( (k = e.key) == key || (key != null &amp;&amp; key.equals( k ) ) ) )\t\t\t\t\t/* 相等，跳出循环 */\t\t\t\t\tbreak;\t\t\t\t/* 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 */\t\t\t\tp = e;\t\t\t&#125;\t\t&#125;\t\t/* 判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个值 */\t\tif ( e != null )\t\t&#123;\t\t\t/* 记录e的value */\t\t\tV oldValue = e.value;\t\t\t/* onlyIfAbsent为false或者旧值为null */\t\t\tif ( !onlyIfAbsent || oldValue == null )\t\t\t\t/* 用新值替换旧值 */\t\t\t\te.value = value;\t\t\t/* 访问后回调 */\t\t\tafterNodeAccess( e );\t\t\t/* 返回旧值 */\t\t\treturn(oldValue);\t\t&#125;\t&#125;\t/* 结构性修改 */\t++modCount;\t/*\t * 步骤⑥：超过最大容量就扩容\t * 实际大小大于阈值则扩容\t */\tif ( ++size &gt; threshold )\t\tresize();\t/* 插入后回调 */\tafterNodeInsertion( evict );\treturn(null);&#125;\n\n\n判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；\n根据键值key计算hash值得到插入的数组索引i，如果table[i]&#x3D;&#x3D;null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；\n判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；\n判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；\n遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；\n插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。\n\n33. HashMap的扩容操作是怎么实现的？\n在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；\n每次扩展的时候，都是扩展2倍；\n扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上\n\n34. HashMap是怎么解决哈希冲突的？\n答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行；\n\n什么是哈希？\n\nHash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。\n\n什么是哈希冲突？\n\n当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。\n\nHashMap的数据结构\n\n在Java中，保存数据有两种比较简单的数据结构：数组和链表。\n数组的特点是：寻址容易，插入和删除困难；\n链表的特点是：寻址困难，但插入和删除容易；\n\n\n所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用俩种方式：链地址法和开放地址法可以解决哈希冲突：\n链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；\n开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。\n但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4 （即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化\n\nhash()函数\n\n上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：\n\nstatic final int hash(Object key) &#123;\tint h;\treturn (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);// 与自己右移16位进行异或运算（高低位异或）&#125;\n\n\n这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；\n\n总结\n\n简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：\n链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；\n开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。\n\n\n\n35. 能否使用任何类作为 Map 的 key？可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：* 如果类重写了 equals() 方法，也应该重写 hashCode() 方法。* 类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。* 如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。* 用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。\n36. 为什么HashMap中String、Integer这样的包装类适合作为K？\n答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减\n少Hash碰撞的几率\n\n都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况\n内部已重写了 equals() 、 hashCode() 等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；\n\n\n\n37. 如果使用Object作为HashMap的Key，应该怎么办呢？\n答：重写 hashCode() 和 equals() 方法\n重写 hashCode() 是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；\n重写 equals() 方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；\n\n\n\n38. HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？\n答： hashCode() 方法返回的是int整数类型，其范围为-(2 ^ 31)(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过 hashCode() 计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；\n那怎么解决呢？\nHashMap自己实现了自己的 hash() 方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；\n在保证数组长度为2的幂次方的时候，使用 hash() 运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；\n\n\n\n39. HashMap 的长度为什么是2的幂次方\n为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表&#x2F;红黑树长度大致相同。这个实现就是把数据存到哪个链表&#x2F;红黑树中的算法。\n这个算法应该如何设计呢？\n我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length&#x3D;&#x3D;hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。\n\n\n那为什么是两次扰动呢？答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；\n\n40. HashMap 与 HashTable 有什么区别？\n线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；\n效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；\n对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。\n初始容量大小和每次扩充容量大小的不同 ：\n创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。\n创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。\n底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\n推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。\n\n41. 什么是TreeMap 简介\nTreeMap 是一个有序的key-value集合，它是通过红黑树实现的。\nTreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。\nTreeMap是线程非同步的。\n\n42. 如何决定使用 HashMap 还是 TreeMap？\n对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。\n\n43. HashMap 和 ConcurrentHashMap 的区别\nConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）\nHashMap的键值对允许有null，但是ConCurrentHashMap都不允许。\n\n44. ConcurrentHashMap 和 Hashtable 的区别？\nConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\n底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树。Hashtable 和 JDK1.8之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n实现线程安全的方式：\n在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n\n\n\n\n两者的对比图：1、HashTable:2、 JDK1.7的ConcurrentHashMap：3、JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：\n答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。\n\n45. ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？JDK1.7\n\n首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\n在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：\n一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。\n\n\n该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；\nSegment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。\n\nJDK1.8\n\n在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。\n结构如下：\n附加源码，有需要的可以看看\n插入元素过程（建议去看看源码）：\n如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；\n\nelse if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;    if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null)))        break; // no lock when adding to empty bin&#125;\n\n\n如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；\n\nif (fh &gt;= 0) &#123;\tbinCount = 1;\tfor (Node&lt;K,V&gt; e = f;; ++binCount) &#123;\t\tK ek;\t\tif (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123;\t\t\toldVal = e.val;\t\t\tif (!onlyIfAbsent)\t\t\te.val = value;\t\t\tbreak;\t\t&#125;\t\tNode&lt;K,V&gt; pred = e;\t\tif ((e = e.next) == null) &#123;\t\t\tpred.next = new Node&lt;K,V&gt;(hash, key, value, null);\t\t\tbreak;\t\t&#125;\t&#125;&#125;\n\n\n如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；\n如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；\n\n四、辅助工具类46. Array 和 ArrayList 有何区别？\nArray 可以存储基本数据类型和对象，ArrayList 只能存储对象。\nArray 是指定固定大小的，而 ArrayList 大小是自动扩展的。\nArray 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList有。对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。\n\n47. 如何实现 Array 和 List 之间的转换？\nArray 转 List： Arrays. asList(array) ；\nList 转 Array：List 的 toArray() 方法。\n\n48. comparable 和 comparator的区别？\ncomparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序\ncomparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序\n一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().\n\n49. Collection 和 Collections 有什么区别？\njava.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。\nCollections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。\n\n50. TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？\nTreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。\nCollections 工具类的 sort 方法有两种重载的形式，\n第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；\ncomparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序\ncomparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序\n一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().\n\n51. Collection 和 Collections 有什么区别？\njava.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。\nCollections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。\n\n52. TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？\nTreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。\nCollections 工具类的 sort 方法有两种重载的形式，\n第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；\n第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。\n\n\n","tags":["Java面试题"]},{"title":"Java基础面试题","url":"/2023/07/25/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"\n一、Java概述1. 何为编程\n编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。\n为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。\n\n2. 什么是Java\nJava是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。\n\n3. jdk1.5之后的三大版本\nJava SE（J2SE，Java 2 Platform Standard Edition，标准版）Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。\nJava EE（J2EE，Java 2 Platform Enterprise Edition，企业版）Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE\nJava ME（J2ME，Java 2 Platform Micro Edition，微型版）Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 JavaME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。\n\n4. Jdk和Jre和JVM的区别看Java官方的图片，Jdk中包括了Jre，Jre中包括了JVM\n\n\nJDK ：Jdk还包括了一些Jre之外的东西 ，就是这些东西帮我们编译Java代码的， 还有就是监控Jvm的一些工具 Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等\nJRE ：Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 JavaRuntime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。\nJvm：在倒数第二层 由他可以在（最后一层的）各种平台上运行 Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。\n\n5. 什么是跨平台性？原理是什么所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。\n6. Java语言有哪些特点\n简单易学（Java语言的语法与C语言和C++语言很接近）\n面向对象（封装，继承，多态）\n平台无关性（Java虚拟机实现平台无关性）\n支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）\n支持多线程（多线程机制使应用程序在同一时间并行执行多项任）\n健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）\n安全性好\n\n7. 什么是字节码？采用字节码的最大好处是什么\n字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。\n采用字节码的好处：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。\n先看下java中的编译器和解释器：Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。\n\n8. 什么是Java程序的主类？应用程序和小程序的主类有何不同？\n一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。\n\n9. Java应用程序与小程序之间有那些差别？\n简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。\n\n10. Java和C++的区别\n我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！\n\n\n都是面向对象的语言，都支持封装、继承和多态\nJava不提供指针来直接访问内存，程序内存更加安全\nJava的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。\nJava有自动内存管理机制，不需要程序员手动释放无用内存\n\n11. Oracle JDK 和 OpenJDK 的对比\nOracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；\nOpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；\nOracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业&#x2F;商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；\n在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；\nOracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；\nOracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。\n\n\n二、基础语法数据类型12. Java有哪些数据类型定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。分类\n\n基本数据类型\n数值型\n整数类型(byte,short,int,long)* 浮点类型(float,double)* 字符型(char)* 布尔型(boolean)\n\n\n引用数据类型- 类(class)  - 接口(interface)  - 数组([])\n\nJava基本数据类型图\n13. switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String上\n在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。\n\n14. 用最有效率的方法计算 2 乘以 8\n2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。\n\n15. Math.round(11.5) 等于多少？Math.round(-11.5)等于多少\nMath.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。\n\n16. float f&#x3D;3.4;是否正确\n不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f &#x3D;(float)3.4; 或者写成 float f &#x3D;3.4F;。\n\n17. short s1 &#x3D; 1; s1 &#x3D; s1 + 1;有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1;有错吗\n对于 short s1 &#x3D; 1; s1 &#x3D; s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。\n而 short s1 &#x3D; 1; s1 +&#x3D; 1;可以正确编译，因为 s1+&#x3D; 1;相当于 s1 &#x3D; (short(s1 + 1);其中有隐含的强制类型转换。\n\n编码18. Java语言采用何种编码方案？有何特点？\nJava语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。\n\n注释19. Java注释定义：用于解释说明程序的文字分类\n\n单行注释格式： &#x2F;&#x2F; 注释文字\n多行注释格式： &#x2F;* 注释文字 *&#x2F;\n文档注释格式：&#x2F;** 注释文字 *&#x2F;\n\n作用\n\n在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。注意事项：多行和文档注释都不能嵌套使用。\n\n访问修饰符20. 访问修饰符 public,private,protected,以及不写（默认）时的区别\n定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。\n分类\nprivate : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\ndefault (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\nprotected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。\npublic : 对所有类可见。使用对象：类、接口、变量、方法\n\n访问修饰符图\n运算符21. &amp;和&amp;&amp;的区别\n&amp;运算符有两种用法：(1)按位与；(2)逻辑与。\n&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。\n\n关键字22. Java 有没有 goto\ngoto 是 Java 中的保留字，在目前版本的 Java 中没有使用。\n\n23. final 有什么用？用于修饰类、属性和方法；\n\n被final修饰的类不可以被继承\n被final修饰的方法不可以被重写\n被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的\n\n24. final finally finalize区别\nfinal可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。\nfinally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\nfinalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的 最后判断。\n\n25. this关键字的用法\nthis是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。\n\nthis的用法在java中大体可以分为3种：\n\n1.普通的直接引用，this相当于是指向当前对象本身。\n\n2.形参与成员名字重名，用this来区分：\npublic Person(String name, int age) &#123;   this.name = name;   this.age = age;&#125;\n\n\n3.引用本类的构造函数\nclass Person&#123;\tprivate String name;\tprivate int age;\tpublic Person() &#123;\t&#125;\tpublic Person(String name) &#123;\t\tthis.name = name;\t&#125;\tpublic Person(String name, int age) &#123;\t\tthis(name);\t\tthis.age = age;\t&#125;&#125;\n\n26. super关键字的用法\nsuper可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。\n\nsuper也有三种用法：\n1.普通的直接引用\n与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。\n2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分\nclass Person&#123;\tprotected String name;\tpublic Person(String name) &#123;\t\tthis.name = name;\t&#125;&#125;class Student extends Person&#123;\tprivate String name;\tpublic Student(String name, String name1) &#123;\t\tsuper(name);\t\tthis.name = name1;\t&#125;\tpublic void getInfo()&#123;\t\tSystem.out.println(this.name); //Child\t\tSystem.out.println(super.name); //Father\t&#125;&#125;public class Test &#123;\tpublic static void main(String[] args) &#123;\t\tStudent s1 = new Student(&quot;Father&quot;,&quot;Child&quot;);\t\ts1.getInfo();\t&#125;&#125;\n\n3.引用父类构造函数\n\nsuper（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。\n\nthis（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。\n\n\n27. this与super的区别\nsuper: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）\nthis：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）\nsuper()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。\nsuper()和this()均需放在构造方法内第一行。\n尽管可以用this调用一个构造器，但却不能调用两个。\nthis和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。\nthis()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。\n从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。\n\n28. static存在的主要意义\nstatic的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！\nstatic关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。\n为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。\n\n29. static的独特之处1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。\n\n怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗 了，你明白了咩？\n\n2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。\n30. static应用场景\n因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。\n因此比较常见的static应用场景有：1、修饰成员变量2、修饰成员方法3、静态代码块4、修饰类【只能修饰内部类也就是静态内部类】5、静态导包\n\n31. static注意事项1、静态只能访问静态。2、非静态既可以访问非静态的，也可以访问静态的。\n流程控制语句32. break ,continue ,return 的区别及作用\nbreak 跳出总上一层循环，不再执行循环(结束当前的循环体)\ncontinue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)\nreturn 程序返回，不再执行下面的代码(结束当前的方法 直接返回)\n\n33. 在 Java 中，如何跳出当前的多重嵌套循环\n在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：\n\npublic static void main(String[] args) &#123;\tok:\tfor (int i = 0; i &lt; 10; i++) &#123;\t\tfor (int j = 0; j &lt; 10; j++) &#123;\t\t\tSystem.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);\t\t\tif (j == 5) &#123;\t\t\t\tbreak ok;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n三、面向对象面向对象概述34. 面向对象和面向过程的区别\n面向过程：\n\n优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux&#x2F;Unix等一般采用面向过程开发，性能是最重要的因素。\n缺点：没有面向对象易维护、易复用、易扩展\n\n\n面向对象：\n\n优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护\n缺点：性能比面向过程低\n\n\n\n面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。\n面向对象三大特性35. 面向对象的特征有哪些方面面向对象的特征主要有以下几个方面：\n\n抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。\n封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。\n继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。\n关于继承如下 3 点请记住：\n子类拥有父类非 private 的属性和方法。\n子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n子类可以用自己的方式实现父类的方法。（以后介绍）。\n\n\n多态：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。\n\n36. 什么是多态机制？Java语言是如何实现多态的？\n所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。\n多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。多态的实现\nJava实现多态有三个必要条件：继承、重写、向上转型。\n继承：在多态中必须存在有继承关系的子类和父类。\n重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。\n向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。\n\n\n\n只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。\n37. 面向对象五大基本原则是什么（可选）\n单一职责原则SRP(Single Responsibility Principle)类的功能要单一，不能包罗万象，跟杂货铺似的。\n开放封闭原则OCP(Open－Close Principle)一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。\n里式替换原则LSP(the Liskov Substitution Principle LSP)子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~\n依赖倒置原则DIP(the Dependency Inversion Principle DIP)高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。\n接口分离原则ISP(the Interface Segregation Principle ISP)设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。\n\n类与接口38. 抽象类和接口的对比\n抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。\n从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。\n\n相同点* 接口和抽象类都不能实例化* 都位于继承的顶端，用于被其他实现或继承* 都包含抽象方法，其子类都必须覆写这些抽象方法\n不同点\n\n\n\n参数\n抽象类\n接口\n\n\n\n声明\n抽象类使用abstract关键字声明\n接口使用interface关键字声明\n\n\n实现\n子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现\n子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现\n\n\n构造器\n抽象类可以有构造器\n接口不能有构造器访\n\n\n问修饰符\n抽象类中的方法可以是任意访问修饰符\n接口方法默认修饰符是public。并且不允许定义为 private 或者protected\n\n\n多继承\n一个类最多只能继承一个抽象类\n一个类可以实现多个接口\n\n\n字段声明\n抽象类的字段声明可以是任意的\n接口的字段默认都是 static 和 final的\n\n\n备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。\n\n接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：\n行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。\n选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。\n\n\n\n39. 普通类和抽象类有哪些区别？\n普通类不能包含抽象方法，抽象类可以包含抽象方法。\n抽象类不能直接实例化，普通类可以直接实例化。\n\n40. 抽象类能使用 final 修饰吗？\n不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类\n\n41. 创建一个对象用什么关键字？对象实例与对象引用有何不同？\nnew关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）\n\n变量与方法42. 成员变量与局部变量的区别有哪些\n变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域\n成员变量：方法外部，类内部定义的变量\n局部变量：类的方法中的变量。\n成员变量和局部变量的区别\n\n作用域\n\n成员变量：针对整个类有效。\n局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)\n\n存储位置\n\n成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。\n局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。\n\n生命周期\n\n成员变量：随着对象的创建而存在，随着对象的消失而消失\n局部变量：当方法调用完，或者语句结束后，就自动释放。\n\n初始值成员变量：有默认初始值。局部变量：没有默认初始值，使用前必须赋值。\n43. 在Java中定义一个不做事且没有参数的构造方法的作用\nJava程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。\n\n44. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？\n帮助子类做初始化工作。\n\n45. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？\n主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。\n\n46. 构造方法有哪些特性？\n名字与类名相同；\n没有返回值，但不能用void声明构造函数；\n生成类的对象时自动执行，无需调用。\n\n47. 静态变量和实例变量区别\n静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。\n实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。\n\n48. 静态变量与普通变量区别\nstatic变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。\n还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。\n\n49. 静态方法和实例方法有何不同？静态方法和实例方法的区别主要体现在两个方面：\n\n在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。\n静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制\n\n50. 在一个静态方法内调用一个非静态成员为什么是非法的？\n由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。\n\n51. 什么是方法的返回值？返回值的作用是什么？\n方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！\n\n内部类52. 什么是内部类？\n在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。\n\n53. 内部类的分类有哪些\n内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。\n\n静态内部类\n\n定义在类内部的静态类，就是静态内部类。\n\npublic class Outer &#123;\tprivate static int radius = 1;\tstatic class StaticInner &#123;\t\tpublic void visit() &#123;\t\t\tSystem.out.println(&quot;visit outer static variable:&quot; + radius);\t\t&#125;\t&#125;&#125;\n\n\n静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式， new 外部类.静态内部类() ，如下：\n\nOuter.StaticInner inner = new Outer.StaticInner();inner.visit();\n\n成员内部类\n\n定义在类内部，成员位置上的非静态类，就是成员内部类。\n\npublic class Outer &#123;\tprivate static int radius = 1;\tprivate int count =2;\tclass Inner &#123;\t\tpublic void visit() &#123;\t\t\tSystem.out.println(&quot;visit outer static variable:&quot; + radius);\t\t\tSystem.out.println(&quot;visit outer variable:&quot; + count);\t\t&#125;\t&#125;&#125;\n\n\n成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式 外部类实例.new 内部类() ，如下：\n\nOuter outer = new Outer();Outer.Inner inner = outer.new Inner();inner.visit();\n\n局部内部类\n\n定义在方法中的内部类，就是局部内部类。\n\npublic class Outer &#123;\tprivate int out_a = 1;\tprivate static int STATIC_b = 2;\tpublic void testFunctionClass()&#123;\t\tint inner_c =3;\t\tclass Inner &#123;\t\t\tprivate void fun()&#123;\t\t\t\tSystem.out.println(out_a);\t\t\t\tSystem.out.println(STATIC_b);\t\t\t\tSystem.out.println(inner_c);\t\t\t&#125;\t\t&#125;\t\tInner inner = new Inner();\t\tinner.fun();\t&#125;\tpublic static void testStaticFunctionClass()&#123;\t\tint d =3;\t\tclass Inner &#123;\t\t\tprivate void fun()&#123;\t\t\t\t// System.out.println(out_a); 编译错误，定义在静态方法中的局部\t\t\t\t类不可以访问外部类的实例变量\t\t\t\tSystem.out.println(STATIC_b);\t\t\t\tSystem.out.println(d);\t\t\t&#125;\t\t&#125;\t\tInner inner = new Inner();\t\tinner.fun();\t&#125;&#125;\n\n\n定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内， new 内部类() ，如下：\n\npublic static void testStaticFunctionClass()&#123;\tclass Inner &#123;\t&#125;\tInner inner = new Inner();&#125;\n\n匿名内部类\n\n匿名内部类就是没有名字的内部类，日常开发中使用的比较多。\n\npublic class Outer &#123;\tprivate void test(final int i) &#123;\t\tnew Service() &#123;\t\t\tpublic void method() &#123;\t\t\t\tfor (int j = 0; j &lt; i; j++) &#123;\t\t\t\t\tSystem.out.println(&quot;匿名内部类&quot; );\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;.method();\t&#125;&#125;//匿名内部类必须继承或实现一个已有的接口interface Service&#123;\tvoid method();&#125;\n\n\n除了没有名字，匿名内部类还有以下特点：匿名内部类必须继承一个抽象类或者实现一个接口。匿名内部类不能定义任何静态成员和静态方法。当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。\n匿名内部类创建方式：\n\nnew 类/接口&#123;//匿名内部类实现部分&#125;\n\n54. 内部类的优点我们为什么要使用内部类呢？因为它有以下优点：\n\n一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！\n内部类不为同一包的其他类所见，具有很好的封装性；\n内部类有效实现了“多重继承”，优化 java 单继承的缺陷。\n匿名内部类可以很方便的定义回调。\n\n55. 内部类有哪些应用场景\n一些多算法场合\n解决一些非面向对象的语句块。\n适当使用内部类，使得代码更加灵活和富有扩展性。\n当某个类除了它的外部类，不再被其他的类使用时。\n\n56. 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？\n局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？先看这段代码：\n\npublic class Outer &#123;\tvoid outMethod()&#123;\t\tfinal int a =10;\t\tclass Inner &#123;\t\t\tvoid innerMethod()&#123;\t\t\t\tSystem.out.println(a);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n\n以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。\n\n57. 内部类相关，看程序说出运行结果public class Outer &#123;\tprivate int age = 12;\tclass Inner &#123;\t\tprivate int age = 13;\t\tpublic void print() &#123;\t\t\tint age = 14;\t\t\tSystem.out.println(&quot;局部变量：&quot; + age);\t\t\tSystem.out.println(&quot;内部类变量：&quot; + this.age);\t\t\tSystem.out.println(&quot;外部类变量：&quot; + Outer.this.age);\t\t&#125;\t&#125;\tpublic static void main(String[] args) &#123;\t\tOuter.Inner in = new Outer().new Inner();\t\tin.print();\t&#125;&#125;\n\n运行结果：\n\n局部变量：14内部类变量：13外部类变量：12\n\n重写与重载58. 构造器（constructor）是否可被重写（override）\n构造器不能被继承，因此不能被重写，但可以被重载。\n\n59. 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？\n方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。\n重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分\n重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。\n\n对象相等判断60. &#x3D;&#x3D; 和 equals 的区别是什么\n&#x3D;&#x3D; : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型 &#x3D;&#x3D; 比较的是内存地址)\n\nequals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：\n\n情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象。\n情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。\n\n\n举个例子：\npublic class test1 &#123;\tpublic static void main(String[] args) &#123;\t\tString a = new String(&quot;ab&quot;); // a 为一个引用\t\tString b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样\t\tString aa = &quot;ab&quot;; // 放在常量池中\t\tString bb = &quot;ab&quot;; // 从常量池中查找\t\tif (aa == bb) // true\t\t\tSystem.out.println(&quot;aa==bb&quot;);\t\tif (a == b) // false，非同一对象\t\t\tSystem.out.println(&quot;a==b&quot;);\t\tif (a.equals(b)) // true\t\t\tSystem.out.println(&quot;aEQb&quot;);\t\tif (42 == 42.0) &#123; // true\t\t\tSystem.out.println(&quot;true&quot;);\t\t&#125;\t&#125;&#125;1234567891011121314151617\n\n说明：\n\nString中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。\n当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。\n\n61. hashCode 与 equals (重要)\nHashSet如何检查重复\n两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？\nhashCode和equals方法的关系\n面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”\n\nhashCode()介绍\n\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。\n散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）\n\n为什么要有 hashCode我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：\n\n当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。\n\nhashCode()与equals()的相关规定\n\n如果两个对象相等，则hashcode一定也是相同的\n两个对象相等，对两个对象分别调用equals方法都返回true\n两个对象有相同的hashcode值，它们也不一定是相等的\n\n因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n62. 对象的相等与指向他们的引用相等，两者有什么不同？\n对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。\n\n值传递63. 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递\n是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的\n\n64. 为什么 Java 中只有值传递\n首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。\n\nJava程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是\n说，方法不能修改传递给它的任何参数变量的内容。\n\n下面通过 3 个例子来给大家说明example 1\n\n\n\npublic static void main(String[] args) &#123;\tint num1 = 10;\tint num2 = 20;\tswap(num1, num2);\tSystem.out.println(&quot;num1 = &quot; + num1);\tSystem.out.println(&quot;num2 = &quot; + num2);&#125;public static void swap(int a, int b) &#123;\tint temp = a;\ta = b;\tb = temp;\tSystem.out.println(&quot;a = &quot; + a);\tSystem.out.println(&quot;b = &quot; + b);&#125;\n\n\n结果：a &#x3D; 20 b &#x3D; 10 num1 &#x3D; 10 num2 &#x3D; 20\n解析：\n在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。\n\n通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看example.example 2\npublic static void main(String[] args) &#123;\tint[] arr = &#123; 1, 2, 3, 4, 5 &#125;;\tSystem.out.println(arr[0]);\tchange(arr);\tSystem.out.println(arr[0]);&#125;public static void change(int[] array) &#123;\t// 将数组的第一个元素变为0\tarray[0] = 0;&#125;\n\n\n结果：1 0\n解析：\n\narray 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。\n\n通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。example 3\npublic class Test &#123;\tpublic static void main(String[] args) &#123;\t\t// TODO Auto-generated method stub\t\tStudent s1 = new Student(&quot;小张&quot;);\t\tStudent s2 = new Student(&quot;小李&quot;);\t\tTest.swap(s1, s2);\t\tSystem.out.println(&quot;s1:&quot; + s1.getName());\t\tSystem.out.println(&quot;s2:&quot; + s2.getName());\t&#125;\tpublic static void swap(Student x, Student y) &#123;\t\tStudent temp = x;\t\tx = y;\t\ty = temp;\t\tSystem.out.println(&quot;x:&quot; + x.getName());\t\tSystem.out.println(&quot;y:&quot; + y.getName());\t&#125;&#125;\n\n\n结果：x:小李 y:小张 s1:小张 s2:小李\n解析：\n交换之前：\n交换之后：\n通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝\n总结\nJava程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。\n\n\n下面再总结一下Java中方法参数的使用情况：\n一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》\n一个方法可以改变一个对象参数的状态。\n一个方法不能让对象参数引用一个新的对象。\n\n\n\n65. 值传递和引用传递有什么区别\n值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。\n\nJava包66. JDK 中常用的包有哪些\njava.lang：这个是系统的基础类；\njava.io：这里面是所有输入输出有关的类，比如文件操作等；\njava.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；\njava.net：这里面是与网络有关的类；\njava.util：这个是系统辅助类，特别是集合类；\njava.sql：这个是数据库操作的类。\n\n67. import java和javax有什么区别\n刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。所以，实际上java和javax没有区别。这都是一个名字。\n\n四、IO流68. java 中 IO 流分为几种?\n按照流的流向分，可以分为输入流和输出流；\n按照操作单元划分，可以划分为字节流和字符流；\n按照流的角色划分为节点流和处理流。\n\nJava Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。\n\nInputStream&#x2F;Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。\nOutputStream&#x2F;Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。\n\n按操作方式分类结构图：\n按操作对象分类结构图：\n69. BIO,NIO,AIO 有什么区别?\n简答\nBIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\nNIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n\n详细回答\nBIO (Blocking I&#x2F;O): 同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I&#x2F;O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I&#x2F;O 处理模型来应对更高的并发量。\nNIO (New I&#x2F;O): NIO是一种同步非阻塞的I&#x2F;O模型，在Java 1.4 中引入了NIO框架，对应java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Nonblocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发\nAIO (Asynchronous I&#x2F;O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。\n\n\n\n70. Files的常用方法都有哪些？\nFiles. exists()：检测文件路径是否存在。\nFiles. createFile()：创建文件。\nFiles. createDirectory()：创建文件夹。\nFiles. delete()：删除一个文件或目录。\nFiles. copy()：复制文件。\nFiles. move()：移动文件。\nFiles. size()：查看文件个数。\nFiles. read()：读取文件。\nFiles. write()：写入文件。\n\n五、反射71. 什么是反射机制？\nJAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。\n静态编译和动态编译\n静态编译：在编译时确定类型，绑定对象\n动态编译：运行时确定类型，绑定对象\n\n\n\n72. 反射机制优缺点\n优点： 运行期类型的判断，动态加载类，提高代码灵活度。\n缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。\n\n73. 反射机制的应用场景有哪些？\n反射是框架设计的灵魂。\n在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。\n举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性\n\n74. Java获取反射的三种方法1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制\npublic class Student &#123;\tprivate int id;\tString name;\tprotected boolean sex;\tpublic float score;&#125;public class Get &#123;\t//获取反射机制三种方式\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\t\t//方式一(通过建立对象)\t\tStudent stu = new Student();\t\tClass classobj1 = stu.getClass();\t\tSystem.out.println(classobj1.getName());\t\t//方式二（所在通过路径-相对路径）\t\tClass classobj2 = Class.forName(&quot;fanshe.Student&quot;);\t\tSystem.out.println(classobj2.getName());\t\t//方式三（通过类名）\t\tClass classobj3 = Student.class;\t\tSystem.out.println(classobj3.getName());\t&#125;&#125;\n\n\n六、常用APIString相关75. 字符型常量和字符串常量的区别\n形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符\n含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)\n占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)\n\n76. 什么是字符串常量池？\n字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。\n\n77. String 是最基本的数据类型吗\n不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars &#x3D; {‘你’,‘好’};但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。\n\n78. String有哪些特性\n不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。\n常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。\nfinal：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。\n\n79. String为什么是不可变的吗？\n简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：&#x2F;** The value is used for character storage. *&#x2F; private final char value[];\n\n80. String真的是不可变的吗？我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：1 String不可变但不代表引用不可以变\nString str = &quot;Hello&quot;;str = str + &quot; World&quot;;System.out.println(&quot;str=&quot; + str);\n\n\n结果：str&#x3D;Hello World\n解析：\n实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”HelloWorld”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。2.通过反射是可以修改所谓的“不可变”对象\n\n// 创建字符串&quot;Hello World&quot;， 并赋给引用sString s = &quot;Hello World&quot;;System.out.println(&quot;s = &quot; + s); // Hello World// 获取String类中的value字段Field valueFieldOfString = String.class.getDeclaredField(&quot;value&quot;);// 改变value属性的访问权限valueFieldOfString.setAccessible(true);// 获取s对象上的value属性的值char[] value = (char[]) valueFieldOfString.get(s);// 改变value所引用的数组中的第5个字符value[5] = &#x27;_&#x27;;System.out.println(&quot;s = &quot; + s); // Hello_World\n\n\n结果：s &#x3D; Hello World s &#x3D; Hello_World\n解析：\n用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。\n\n81. 是否可以继承 String 类\nString 类是 final 类，不可以被继承。\n\n82. String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？\n不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。\n\n83. String s &#x3D; new String(“xyz”);创建了几个字符串对象\n两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。\n\nString str1 = &quot;hello&quot;; //str1指向静态区 String str2 = new String(&quot;hello&quot;); //str2指向堆上的对象String str3 = &quot;hello&quot;; String str4 = new String(&quot;hello&quot;); System.out.println(str1.equals(str2));//true System.out.println(str2.equals(str4)); //true System.out.println(str1 == str3); //trueSystem.out.println(str1 == str2); //false System.out.println(str2 == str4); //falseSystem.out.println(str2 == &quot;hello&quot;); //false str2 = str1; System.out.println(str2 == &quot;hello&quot;);//true\n\n84. 如何将字符串反转？\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n示例代码：\n\n// StringBuffer reverse StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(&quot;abcdefg&quot;); System.out.println(stringBuffer. reverse()); // gfedcba // StringBuilder reverse StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(&quot;abcdefg&quot;);System.out.println(stringBuilder. reverse()); // gfedcba\n\n85. 数组有没有 length()方法？String 有没有 length()方法\n数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。\n\n86. String 类的常用方法都有那些？\nindexOf()：返回指定字符的索引。\ncharAt()：返回指定索引处的字符。\nreplace()：字符串替换。\ntrim()：去除字符串两端空白。\nsplit()：分割字符串，返回一个分割后的字符串数组。\ngetBytes()：返回字符串的 byte 类型数组。\nlength()：返回字符串长度。\ntoLowerCase()：将字符串转成小写字母。\ntoUpperCase()：将字符串转成大写字符。\nsubstring()：截取字符串。\nequals()：字符串比较。\n\n87. 在使用 HashMap 的时候，用 String 做 key 有什么好处？\nHashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。\n\n88. String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的可变性\n\nString类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。\n\n线程安全性\n\nString中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。\n\n性能\n\n每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n对于三者使用的总结\n\n如果要操作少量的数据用 &#x3D; String\n单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder\n多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer\n\n包装类相关89. 自动装箱与拆箱\n装箱：将基本类型用它们对应的引用类型包装起来；\n拆箱：将包装类型转换为基本数据类型；\n\n90. int 和 Integer 有什么区别\nJava 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。\nJava 为每个原始类型提供了包装类型：\n原始类型: boolean，char，byte，short，int，long，float，double\n包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double\n\n\n\n91. Integer a&#x3D; 127 与 Integer b &#x3D; 127相等吗\n对于对象引用类型：&#x3D;&#x3D;比较的是对象的内存地址。\n对于基本数据类型：&#x3D;&#x3D;比较的是值。\n\n如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1&#x3D;&#x3D;b1的结果是false\npublic static void main(String[] args) &#123;\tInteger a = new Integer(3);\tInteger b = 3; // 将3自动装箱成Integer类型\tint c = 3;\tSystem.out.println(a == b); // false 两个引用没有引用同一对象\tSystem.out.println(a == c); // true a自动拆箱成int类型再和c比较\tSystem.out.println(b == c); // true\tInteger a1 = 128;\tInteger b1 = 128;\tSystem.out.println(a1 == b1); // false\tInteger a2 = 127;\tInteger b2 = 127;\tSystem.out.println(a2 == b2); // true&#125;\n\n\n","tags":["Java面试题"]}]